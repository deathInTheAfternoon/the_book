<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Enums - The Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="rust_enums.html"><strong aria-hidden="true">1.</strong> Rust Enums</a></li><li class="chapter-item expanded "><a href="front_proxy.html"><strong aria-hidden="true">2.</strong> Example: front proxy load balancer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="example_front_proxy/simple_http_server.html"><strong aria-hidden="true">2.1.</strong> Rust HTTP server</a></li><li class="chapter-item expanded "><a href="example_front_proxy/dockerize_server.html"><strong aria-hidden="true">2.2.</strong> Dockerize the server</a></li><li class="chapter-item expanded "><a href="example_front_proxy/obeservations.html"><strong aria-hidden="true">2.3.</strong> Observational notes</a></li></ol></li><li class="chapter-item expanded "><a href="labs/namespaces/lab_namespaces.html"><strong aria-hidden="true">3.</strong> Labs: Namespaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="labs/namespaces/host_host.html"><strong aria-hidden="true">3.1.</strong> First smart cable (host to host)</a></li><li class="chapter-item expanded "><a href="labs/namespaces/host_red.html"><strong aria-hidden="true">3.2.</strong> Smart cable from computer to host</a></li><li class="chapter-item expanded "><a href="labs/namespaces/red_blue.html"><strong aria-hidden="true">3.3.</strong> 2 computers (point-point)</a></li><li class="chapter-item expanded "><a href="labs/namespaces/red_br_blue.html"><strong aria-hidden="true">3.4.</strong> Two computers (bridged)</a></li><li class="chapter-item expanded "><a href="labs/namespaces/red_green_blue.html"><strong aria-hidden="true">3.5.</strong> 3 computers (point-point)</a></li><li class="chapter-item expanded "><a href="labs/namespaces/internet_access.html"><strong aria-hidden="true">3.6.</strong> Finale: internet access</a></li></ol></li><li class="chapter-item expanded "><a href="networking.html"><strong aria-hidden="true">4.</strong> Networking (L2 + L3)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Step by step introcution to enums in Rust.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>You want to model different types of single selection 'pick list' for users of your API. Here are some examples:</p>
<ul>
<li>Your 'reminder' API allows client code to select a single day of week {Monday, Tuesday, Wednesday,...}.</li>
<li>Your 'reminder' API also allows client code to select a single month {January, February, March,...}</li>
<li>Your GUI framework API signals client code when user events have occurred {Paste, MouseClick, KeyPress, Draw,...}</li>
<li>Some calls in your API return one of {Success, Failure} to calling code. This is the basis for Rust's Result enum.</li>
<li>Some calls in your API return one of {Something, Nothing} to avoid transmitting null values. This is the basis for Rust's Option enum.</li>
<li>Your 'logging' API allows a call site to specify a trace level from one of {DEBUG, INFO, ERROR, WARN}</li>
<li>Your drawing API sets background colours using one of a list {Red, Blue, Green, White, Black,...};</li>
</ul>
<p>It's worth noting that none of the above are 'universal' values, external constraints or limits of your system. These are modeled by constants (e.g. Pi, maximum number of file handles, maximum size of integer, platform...). There is no list and no selection involved, just a value that is fixed while your software runs. However, what is constant for an enum is the number of items in the list itself.</p>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<p>In the above examples, each pick list is distinct. A colour is not a day is not a month. In other words, they are different types of list. Consider the issue with the following snippet:</p>
<pre><code class="language-rust noplayground">// Reminder API has two methods
fn setDay(day: &amp;str);
fn setMonth(month: &amp;str);

// This is bound to happen...
x: &amp;str = &quot;Monday&quot;;
y: &amp;str = &quot;January&quot;;
// Sometime later...
setDay(y);
setMonth(x);
</code></pre>
<p>The problem is that the compiler cannot distinguish between each list and its items. Fortunately, each Rust enum is a distinct type of list. For example:</p>
<pre><code class="language-rust noplayground">enum DayOfWeek {
    // list items will go here
}

enum MonthOfYear {
    // list items will go here
}
</code></pre>
<p>We can now declare a variable of either type and we can define a value of either type. But the compiler will prevent a DayOfWeek value (e.g. &quot;Monday&quot;) being assigned to a MonthOfYear variable.</p>
<h2 id="enum-variants"><a class="header" href="#enum-variants">Enum variants</a></h2>
<p>Each item in the list of possible values is called a <em>variant</em>. Variants can have different structures so let's start with the simplest, fieldless variants.</p>
<h3 id="fieldless-variant"><a class="header" href="#fieldless-variant">Fieldless variant</a></h3>
<p>Let's expand our DayOfWeek type to include some actual items:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DayOfWeek {
    Monday,
    Tuesday,
}
<span class="boring">}
</span></code></pre></pre>
<p>'Monday' is an enum variant as is 'Tuesday'. The variants shown here are called 'fieldless'. That's because, in contrast to other variant types (e.g. structure or tuple), the item has no fields (members).</p>
<p>How do we actually use an enum? We define (declare and initialize) as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DayOfWeek {
    Monday,
    Tuesday,
    Wednesday,
}
// Declare a variable of type DayOfWeek and initialize it with a value:
let d1: DayOfWeek = DayOfWeek::Monday;

// Use enum type to delcare a function parameter:
fn log(d: DayOfWeek) {
    // Match a supplied argument against each possible variant:
    match d {
        DayOfWeek::Monday =&gt; println!(&quot;First day of week&quot;),
        DayOfWeek::Tuesday =&gt; println!(&quot;Second day of week&quot;),
        DayOfWeek::Wednesday =&gt; println!(&quot;Third day of week&quot;),
    }
}

log(d1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="tuple-variant"><a class="header" href="#tuple-variant">Tuple variant</a></h3>
<p>TODO: explain why a list item can contain values.</p>
<p>This variant allows an item to have unnamed fields. The item is defined using a tuple constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GUIEvent {
    KeyPress(key: String),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="struct-variant"><a class="header" href="#struct-variant">Struct variant</a></h3>
<p>Item can have named fields which are defined using a struct constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GUIEvent {
    MouseClick {x: i32, y: i32},
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="discriminant"><a class="header" href="#discriminant">Discriminant</a></h3>
<p>Each variant is implicitly assigned an integer value ('isize') under the covers. This integer is used by the Rust compiler to ascertain which variant an enum instance holds. We can import a function called 'discriminant' which reveals that internal value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum DayOfWeek {
        Monday,
        Tuesday,
    }
    println!(&quot;Monday variant was implicitly assigned {:?}&quot;, 
            mem::discriminant(&amp;DayOfWeek::Monday));
    println!(&quot;Tuesday variant was implicitly assigned {:?}&quot;, 
            mem::discriminant(&amp;DayOfWeek::Tuesday));
<span class="boring">}
</span></code></pre></pre>
<p>TODO: You can also cast to i32 'as i32'.</p>
<h3 id="explicit-discriminant"><a class="header" href="#explicit-discriminant">Explicit discriminant</a></h3>
<p>If your enum contains only fieldless variants you can explicitly set the value of the discriminant:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum DayOfWeek {
        Monday = 2,
        Tuesday,
        Wednesday = 0x1ABC,
        Thursday,
    }
    
    println!(&quot;Monday variant explicitly assigned {:?}&quot;, mem::discriminant(&amp;DayOfWeek::Monday));
    println!(&quot;Tuesday variant implicitly assigned {:?}&quot;, mem::discriminant(&amp;DayOfWeek::Tuesday));
    println!(&quot;Wednesday variant explicitly assigned  {:#X?}&quot;, mem::discriminant(&amp;DayOfWeek::Wednesday));
    println!(&quot;Thursday variant implicitly assigned  {:#X?}&quot;, mem::discriminant(&amp;DayOfWeek::Thursday));
<span class="boring">}
</span></code></pre></pre>
<p>Notice how implicit discriminants are always one more than the last enum item.</p>
<p>Though you may not use explicit descriminants that often they can be used to assign values used as bit flags (see Rust's bitmask) or perhaps the hex value of a small RGB colour swatch.
They can also be assigned when mapping between enums in different libraries e.g. nix wraps libc:</p>
<pre><code class="language-rust noplayground">pub enum Errno {
        UnknownErrno    = 0,
        EPERM           = libc::EPERM,
        ENOENT          = libc::ENOENT,
        ESRCH           = libc::ESRCH,
</code></pre>
<p>Finally, remember that once an enum contains more 'complex' items such as structs or tuples you cannot assign explicit discriminants.</p>
<h1 id="defining-declare-and-initialize-a-variable-of-type-enum"><a class="header" href="#defining-declare-and-initialize-a-variable-of-type-enum">Defining (declare and initialize) a variable of type enum.</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DayOfWeek {
    Monday,
}
let d1: DayOfWeek = DayOfWeek::Monday;
// WARNING: mdbook doesn't like this - but it should work?
// Bring enum type into scope so you don't have to keep initializing variables with 'DayOfWeek::Monday'
use DayOfWeek::Monday;
let d2: DayOfWeek = Monday;
<span class="boring">}
</span></code></pre></pre>
<h3 id="scoping-enum-items"><a class="header" href="#scoping-enum-items">Scoping enum items</a></h3>
<p>The following didn't run within mdbook, but it works elsewhere.</p>
<p>In the above examples you have to explicitly declare the enum type when initializing a variable. </p>
<pre><code class="language-rust noplayground">// Enum item must be fully declared by initializer
let d: DayOfWeek = DayOfWeek::Monday;
</code></pre>
<p>To avoid the extra typing on the RHS you can bring enum items into scope with the 'use' statement:</p>
<pre><code class="language-rust noplayground">// scope single enum item
use DayOfWeek::Monday;
let d: DayOfWeek = Monday;

// scope multiple items
use DayOfWeek::{Monday, Tuesday};
let d: DayOfWeek = Tuesday;

// scope all enum items
use DayOfWeek::*;
let d: DayOfWeek = Saturday;
</code></pre>
<h3 id="prelude-enums"><a class="header" href="#prelude-enums">Prelude enums</a></h3>
<p>The Rust prelude is a list of things Rust automatically imports into every Rust program. It includes enums called Option and Result. That's why you wont need a 'use' statement to import them and you can immediately write statements such as:</p>
<pre><code class="language-rust noplayground">let r: Result&lt;str, i32&gt; = Ok(&quot;yay&quot;);
let o: Option&lt;str&gt; = Some(&quot;some value&quot;);
</code></pre>
<p>No need to worry about the unusual syntax for now. All you need to appreciate is that Rust has automatically imported some enum types and so you can use their variants without 'use' statements.</p>
<h2 id="formally"><a class="header" href="#formally">Formally...</a></h2>
<p>An enumerated type is a <em>nominal, heterogeneous, disjoint union</em>. </p>
<p>Most languages use a mix of nominal and structural type systems. A nominal type system will always consider two types different if they differ by name (but might have the same structure). In Rust enums are nominal because Rust only compares two enums by type and, for example, will not allow the initialization of 'a' by values of type 'B' even though they have the same structure.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A {
        X(i32)
    }
    enum B {
        X(i32)
    }

    let a: A = B::X(32);
<span class="boring">}
</span></code></pre></pre>
<p>An enum is a heterogenous union because it allows variants of different types. It is disjoint because only one variant can be assigned to a variable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next" href="front_proxy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next" href="front_proxy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
